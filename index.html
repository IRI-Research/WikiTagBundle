<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Wikitagbundle : A bundle to tag object using wikipedia" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Wikitagbundle</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/IRI-Research/WikiTagBundle">View on GitHub</a>

          <h1 id="project_title">Wikitagbundle</h1>
          <h2 id="project_tagline">A bundle to tag object using wikipedia</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/IRI-Research/WikiTagBundle/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/IRI-Research/WikiTagBundle/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>WikiTagBundle</h1>

<p>WikiTagBundle is a php bundle for <a href="http://symfony.com/">Symfony 2</a> released by the <a href="http://www.iri.centrepompidou.fr/">Institute for research and innovation</a> (IRI).
It enables to add semantised tags to any kind of document. 
By semantised, we mean that a tag has its label, but also a wikipedia link related to this label. Right now, for v1.0, it works with the french wikipedia.
For a simple example, the tag "Asie" is related to the link <a href="http://fr.wikipedia.org/wiki/Asie">http://fr.wikipedia.org/wiki/Asie</a>.
The tag can also be categorised, by any value in a list.
The tag can also have an alias, which is any string value.
When a wikipedia entry is found, the bundle also searches a <a href="http://dbpedia.org/">dbPedia</a> entry for the english equivalent, for example <a href="http://dbpedia.org/page/Asia">http://dbpedia.org/page/Asia</a>.</p>

<p>A tag can have 4 kinds of wikipedia links :</p>

<ul>
<li>
<strong>match</strong> - Perfect match between the label and the wikipedia entry (i.e. <a href="http://fr.wikipedia.org/wiki/Asie">Asie</a>).</li>
<li>
<strong>redirection</strong> - The label exists in wikipedia but redirects to an other entry (i.e. Louis XIV to <a href="http://fr.wikipedia.org/wiki/Louis_XIV_de_France">Louis XIV de France</a>).</li>
<li>
<strong>homonymy</strong> - The label leads to wikipedia homonymy page (i.e. <a href="http://fr.wikipedia.org/wiki/Abstraction">Abstraction</a>).</li>
<li>
<strong>null result</strong> - The label is not related to any wikipedia entry. So we build a link leading to the search page (i.e. <a href="http://fr.wikipedia.org/w/index.php?search=art+multim%C3%A9dia">art multimédia</a>).</li>
</ul><h2>Install</h2>

<p>WikiTagBundle is a php bundle for <a href="http://symfony.com/">Symfony 2</a>.</p>

<ul>
<li>Install the dependencies : <a href="https://github.com/whiteoctober/Pagerfanta">PagerFanta</a> and <a href="https://github.com/mandango/mondator">Mondator</a>.</li>
<li>Download the zipfile from the <a href="https://github.com/">downloads</a> page and install it.</li>
<li>Once unzipped, just copy the IRI folder in your vendor/bundles folder. The folder hierarchy will be vendor/bundles/IRI/Bundle/WikiTagBundle.</li>
</ul><h2>License</h2>

<p>This bundle is under the CeCILL-C license. See the complete license in the bundle:</p>

<pre><code>Resources/meta/LICENSE
</code></pre>

<h2>Getting Started</h2>

<ul>
<li>Install WikiTagBundle</li>
<li>
<p>Register the bundle in AppKernel.php :</p>

<pre><code> ... new IRI\Bundle\WikiTagBundle\WikiTagBundle(), ...
</code></pre>
</li>
<li>
<p>Register the namespace in the autoload.php :</p>

<pre><code> ... 'IRI\Bundle\WikiTagBundle'   =&gt; \_\_DIR\_\_.'/../vendor/bundles', ...
</code></pre>
</li>
<li>
<p>Register the namespace fallbacks in the autoload.php :</p>

<pre><code>$loader-&gt;registerNamespaceFallbacks(array(
    \_\_DIR\_\_.'/../src',
    \_\_DIR\_\_.'/cache/dev/wikitag',
    \_\_DIR\_\_.'/cache/prod/wikitag',
    \_\_DIR\_\_.'/cache/test/wikitag',
    \_\_DIR\_\_.'/cache/task/wikitag',
));
</code></pre>
</li>
<li>
<p>Since WikiTagBundle builds its own document class from the host app's document class, you need to tell in config.yml what is the host app's document class and what <em>text</em> fields will be used in this class. 
These fields are used for searching and to calculate the tag's weight. Example :</p>

<pre><code>wiki_tag:
    document_class: Company\BaseBundle\Entity\Document
    document_id_column: id
    fields:
        title:
            type: string
            length: 1024
            accessor: getTitre
            weight: 1.0
        description:
            type: text
            weight: 0.5
</code></pre>

<p>The 'document_id_column' option is used to indicate the primary key column used by the host app's document class. We are currently limited to non composite primary keys.
A field definition has the following format:
:
type:  : field type. default : text 
length:  : the length of the field. ignored if field type is text
accessor:  : the field name in the host app's document class, or the name of the method used to access the field value. If not found it will try ta add 'get' in frint of the name. Default : the field name
weight:  : the weight used for this field to calculate the score of each tag. default : 1.0 </p>
</li>
<li>
<p>Add the WikiTag routes to your routing.yml :</p>

<pre><code>WikiTagBundle:
    resource: "@WikiTagBundle/Resources/config/routing.yml"
    prefix:   /tag
</code></pre>
</li>
<li>
<p>Run the commands :</p>

<pre><code>php app/console wikitag:generate-document-class (no need to explain)
php app/console wikitag:schema:update (also replace and runs php app/console doctrine:schema:update)
php app/console wikitag:sync-doc (fills the database with the datas from the host document class to the wikitag document class. this command is needed only if the database was not empty)
</code></pre>
</li>
<li>
<p>Your database is ready. You can now include the table of tags in a template. Do not forget css and javascript (and php app/console assets:install). Example :</p>

<pre><code>{# example of page extending the base template #}
{% extends 'CompanyBaseBundle:Default:index.html.twig' %}

{% block css_import %}
{{ parent() }}
{% render "WikiTagBundle:WikiTag:addCss" %}
{% endblock %}

{% block js_declaration %}
{{ parent() }}
{% render "WikiTagBundle:WikiTag:addJavascript" %}
{% endblock %}

{% block content %}
&lt;!-- The beginning of your template --&gt;
        {% render "WikiTagBundle:WikiTag:documentTags" with {'id_doc': doc.id} %}
&lt;!-- The end of your template --&gt;
{% endblock %}
</code></pre>
</li>
<li><p>Great ! You can now add/remove/change semantised tags to your document ! The WikiTag template includes an autocomplete search field to add simply and fastly any wikipedia semantised tag.</p></li>
</ul><h2>The list of all tags</h2>

<p>If you want to, you can add into a page the list of all tags. WikiTagBundle manages a list of all tags with the paginator PagerFanta. By default, it displays 50 tags per page.
The template includes links to quick search via a list of tags's first letter. A search field is also included. It works with the star character (*) as a delimiter for searching.
For example "*Peter" will return tags ending by Peter, "Peter*" tags beginning by Peter, and "*Peter*" all tags including Peter. 
The list can be sorted in ascending or descending label, number of documents or popularity (integer value).
WikiTagBundle manages pagination, search, and sort with url parameters. </p>

<p>Example : <a href="http://mysite.com/route%5C_to%5C_list?searched=Peter%5C*&amp;num%5C_page=1&amp;nb%5C_by%5C_page=50&amp;sort=popd">http://mysite.com/route\_to\_list?searched=Peter\*&amp;num\_page=1&amp;nb\_by\_page=50&amp;sort=popd</a></p>

<p>Including the tag list template looks like :</p>

<pre><code>    {# example of template including the all tags list #}
    {% extends 'CompanyBaseBundle:Default:index.html.twig' %}

    {% block css_import %}
    {{ parent() }}
    {% render "WikiTagBundle:WikiTag:addCss" %}
    {% endblock %}

    {% block js_declaration %}
    {{ parent() }}
    {% render "WikiTagBundle:WikiTag:addJavascript" with {'tags_list': true} %}
    {% endblock %}

    {% block content %}
    &lt;!-- The beginning of your template --&gt;
        {% render "WikiTagBundle:WikiTag:allTags" %}
    &lt;!-- The end of your template --&gt;
    {% endblock %}
</code></pre>

<p><em>IMPORTANT</em> : This template needs a route to be defined in configuration file. Usually, this host site's route leads the a page/document concerned by the clicked tag. 
This route is used by the list to create a link on the "nb of documents" column. config.yml looks like :</p>

<pre><code>    wiki_tag:
        route_for_documents_by_tag: a_route_from_host_site
        document_class: Company\BaseBundle\Entity\Document
        ...
</code></pre>

<h2>More configuration 1 : tag list profile for a document</h2>

<p>Via config.yml, you can configure how columns are displayed for a given user. It also concerns the button "sort tags" 
(this function orders tags depending of their presence in the text fields set in config.yml). 
Is it is very simple. For each profile, you define the display property and the column name. 
The 3 properties available are : 0 : never displayed and not available in the list, 1 : displayed by default and available in the list, 2 : hidden by default but available in the list 
(the user can display the column if he wants, by clicking in the list). If the column is not in the profile or if the visibility parameter is undefined, it is considered as 0.
The column ids are : sort_tag, order, move_up_down, id, label, wikipedia_link, wikipedia_permalink, dbpedia_link, category, remove_wikipedia_link, alias, remove_tag_from_list, alternative_label, alternative_wikipedia_url.
The following example make it understable :</p>

<pre><code>    wiki_tag:
        ...
        document_list_profile:
            all:
                sort_tag:
                    visibility: 0
                order:
                    label:      'Pertinence'
                    visibility: 1
                move_up_down:
                    visibility: 1
                ...
                alternative_label:
                    label:      'Label redirigé'
                    visibility: 2
                alternative_wikipedia_url:
                    label:      'Lien redirigé'
                    visibility: 1
            editor:
                order:
                    label:      '#'
                    visibility: 1
                move_up_down:
                    visibility: 0
                ...
                alias:
                    label:      'Alias'
                    visibility: 1
                remove_tag_from_list:
                    label:      'Retirer le tag'
                    visibility: 2
</code></pre>

<p>In these values, "sort_tag" means the sort tag button. All the other values are the available columns in the tag table.
Once this configuration set, call the profile in your template. The profile has to be called in the javascript call AND in the html call. So your template will look like this :</p>

<pre><code>    ...
    {% render "WikiTagBundle:WikiTag:addJavascript" with {'profile_name': 'editor'} %}
    ...
    {% render "WikiTagBundle:WikiTag:documentTags" with {'id_doc': doc.id, 'profile_name': 'editor'} %}
    ...
</code></pre>

<h2>More configuration 2 : add context seach to any text part of your page</h2>

<p>Via config.yml, you can configure a list of jquery selectors meant to let appear tag context search by selecting text. 
Once some text selected, a little div appears and displays several wikipedia entries with the entry title and a snippet. The results are the same than in an opensearch page 
(example with <a href="http://fr.wikipedia.org/w/index.php?search=d%C3%A9couvrir">découvrir</a>). If you want this functionality, config.yml will look like this : </p>

<pre><code>    wiki_tag:
        ...
        reactive_selectors:
            some_divs:  [ '.left_sheet', '#p_title .sheet_title', '#p_description' ]
            only_p:     [ '#p_title .sheet_title', '#p_description' ]
            whole_page: [ 'document' ]
</code></pre>

<p>If you want every text on your page to be reactive, the list has to be [ 'document' ].
In the templates, you have to call a specific javascript with the wanted parameter. Your javascript calls may look like this :</p>

<pre><code>    {% block js_declaration %}
    {{ parent() }}
    {% render "WikiTagBundle:WikiTag:addJavascript" with {'profile_name': 'editor'} %}
    {% render "WikiTagBundle:WikiTag:addJavascriptForContextSearch" with {'context_name': 'some_divs'} %}
    {% endblock %}
</code></pre>

<h2>More configuration 3 : ignore wikipedia errors</h2>

<p>This option allows to ignore wikipedia errors instead of raising an exception. The error is logged with an ERROR level and the tag is added/updated but not semantized.</p>

<pre><code>    wiki_tag:
        ...    
        ignore_wikipedia_error: true
</code></pre>

<h2>More configuration 4 : curl parameters</h2>

<p>This option enables to add any parameter to the curl requests, since the wikipedia request are made from the server. For example, it is useful when the server is behind a firewall.</p>

<pre><code>    wiki_tag:
        ...    
        curl_options:
            CURLOPT_HTTPPROXYTUNNEL:  'TRUE'
            CURLOPT_PROXYAUTH: 'CURLAUTH_NTLM'
            CURLOPT_USERAGENT: 'Mozilla/5.0 Gecko/20100101 Firefox/10.0.1'
            CURLOPT_PROXY: 'my.proxy.url:1234'
            CURLOPT_PROXYUSERPWD: 'MY-DOMAIN\user:password'
            CURLOPT_PROXYTYPE: 'CURLPROXY_HTTP'
</code></pre>

<h2>Services</h2>

<h3>Document Service : wiki_tag.document - IRI\Bundle\WikiTagBundle\Services\DocumentService</h3>

<p>The document service gathers methods to manage tags on a given document. all these methods must be called after the host app's document(s) object has been created and flushed.</p>

<ul>
<li><p>addTags : add a tag or a list pf tags to a document. For each new tag, wikipedia will be queried.</p></li>
<li><p>copyTags : copy the tags list from one document to the other.</p></li>
<li><p>reorderTags : reorder a document tags. </p></li>
<li><p>getTagsLabels : get the list of tag labels from one document.</p></li>
</ul><h3>Search service : wiki_tag.search - IRI\Bundle\WikiTagBundle\Services\SearchService</h3>

<p>The search service allows searching documents</p>

<ul>
<li><p>getTagCloud : returns a weighted list of tag labels. The weight of the label is the number of documents tagged with this label. The list is sorted by descending weights.  </p></li>
<li><p>search : search documents.</p></li>
</ul><h2>Commands</h2>

<p>This bundle provides a number of commans that helps in the tags management.</p>

<h3>wikitag:schema:create</h3>

<p>Command to create the database schema. Equivalent to the doctrine:schema:create command.
It fully replaces the doctrine:schema:create and <em>must</em> be run instead of the doctrine:schema:create command. </p>

<h3>wikitag:schema:update</h3>

<p>Command to update the database schema. Equivalent to the doctrine:schema:update command.
It fully replaces the doctrine:schema:update and <em>must</em> be run instead of the doctrine:schema:update command.</p>

<h3>wikitag:create-fulltext-indexes</h3>

<p>Generate the sql to create the full text index on the database. This command is not destined to be directly called.</p>

<h3>wikitag:generate-document-class</h3>

<p>Generate the WikiTagBundle document class. This command should not be directly called.</p>

<h3>wikitag:purge-tags</h3>

<p>Removes tags associated to no documents.</p>

<h3>wikitag:query-wikipedia</h3>

<p>Query wikipedia for informations on tags.</p>

<h3>wikitag:reorder-tags</h3>

<p>Automatically reorder documents tags. For each documents treated, each tag of the document is scored according to the fields definition in the bundle configuration. The sorting of the tags is done document by document according to these scores. </p>

<h3>wikitag:sync-doc</h3>

<p>Synchronize the wikiTag Bundle documents with the host bundle. This synchronization is made according to the fields defined in the bundle configuration.</p>

<h3>wikitag:load-fixtures</h3>

<p>Allow loading of fixtures to populate the database.</p>

<p>The wikitag document table must exist and be synchronized. There fore the following commands must have been executed:</p>

<ul>
<li> php app/console wikitag:generate-document-class</li>
<li> php app/console wikitag:sync-doc</li>
</ul><p>The wikitag_document.external_id field must match the datasheet field fo the taggedsheet table.
This command import in order categories, tags and documents_tags.
you may have memory problem. In this case you can import data by slices. Here is an example:</p>

<ul>
<li> all categories : php app/console wikitag:load-fixtures -C /path/to/data.json</li>
<li> all tags : php app/console wikitag:load-fixtures -T /path/to/data.json</li>
<li> 20000 first doctags: php app/console wikitag:load-fixtures -D -E 20000 /path/to/data.json</li>
<li> 20000 other doctags: php app/console wikitag:load-fixtures -D -B 20001 -E 40000 /path/to/data.json</li>
<li> last doctags: php app/console wikitag:load-fixtures -B 40001 /path/to/data.json</li>
</ul><p>The -B (index Begin) and -E (index End) works alson on the tags. Therefore you cans import tags also in slices.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Wikitagbundle maintained by <a href="https://github.com/IRI-Research">IRI-Research</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
